# Example values files for a customer onboarding
# It is huge, especially the NetworkPolicy part ... however, you do not need to use everything. I tried to make it is configurable as possible.

# Name of the custoemrs. This must be the path.basename.
customer.name: my-main-app

# Normalized name of the customer. This must be LOWER case, otherwise ArgoCD will fail
customerNormalized: my-main-app # name for ArgoCD must be in lower case

# Environment to which these values are valid, this should be the cluster name as visible in ArgoCD
environment: in-cluster

local_admin_group:
  enabled: yes
  #group_name: test
  users:
    - mona
    - peter

# Parameters handed over to sub-chart helper-proj-onboarding
helper-proj-onboarding:

  # List of namespaces this customer shall have. Namespace configuration
  namespaces:

    # name of first namespace
    - name: customera-project-1

      # shall namespace be created of not
      enabled: true

      # Additional labels for Podsecurity and Monitoring
      additional_settings:
        # Pod Security Standards
        # https://kubernetes.io/docs/concepts/security/pod-security-standards/#restricted
        # Possible values: Privileged, Baseline, Restricted
        # Privileged: Unrestricted policy, providing the widest possible level of permissions. This policy allows for known privilege escalations.
        # Baseline: Minimally restrictive policy which prevents known privilege escalations. Allows the default (minimally specified) Pod configuration.
        # Restricted: Heavily restricted policy, following current Pod hardening best practices.

        # Policy violations will trigger the addition of an audit annotation to the event recorded in the audit log, but are otherwise allowed.
        podsecurity_audit: restricted
        # Policy violations will trigger a user-facing warning, but are otherwise allowed.
        podsecurity_warn: restricted
        # Policy violations will cause the pod to be rejected.
        podsecurity_enforce: restricted
        cluster_monitoring: true

      # list of labels that should be passed
      labels:
        my_additional_label: my_label
        another_label: another_label

    # name of second namespace
    - name: customera-project-2

      # shall namespace be created of not
      enabled: true

      # Configure resourceQuotas
      # Here are a lot of examples, typically, you do not need all of these. cpu/memory is a good start in usually use cases.
      resourceQuotas:
        enabled: true
        # limits of Pods, CPU, Memory, storage, secrets... etc. etc.
        # Byte values will be replace: gi -> Gi, mi -> Mi
        pods: 4
        cpu: 1
        memory: 2Gi
        ephemeral_storage: 4Gi
        replicationcontrollers: 20
        resourcequotas: 20
        services: 100
        secrets: 100
        configmaps: 100
        persistentvolumeclaims: 10
        limits:
          cpu: 1
          memory: 1gi # will be automatically replaced
          ephemeral_storage: 4mi # will be automatically replaced
        requests:
          cpu: 1
          memory: 2Gi
          storage: 50Gi
          ephemeral_storage: 2Gi
        # add here a list of your storage classes you would like to limit as well.
        storageclasses:
          # for example: Storageclass "bronze" has a request limit and a limit ov max. PVCs.
          bronze.storageclass.storage.k8s.io/requests.storage: "10Gi"
          bronze.storageclass.storage.k8s.io/persistentvolumeclaims: "10"

      # Limit Ranges, are optional, if not set here, then default (very small ones) are used
      limitRanges:
        enabled: true
        pod:
          max:
            cpu: 4
            memory: 100Gi
          min:
            cpu: 1
            memory: 10Gi
        container:
          max:
            cpu: 4
            memory: 100Gi
          min:
            cpu: 1
            memory: 10Gi
          default:
            cpu: 1
            memory: 10Gi
          defaultRequest:
            cpu: 1
            memory: 10Gi
        pvc:
          min:
            storage: 1Gi
          max:
            storage: 20Gi

      # Network Policies ... these are a bit more complex, when you want to keep them fully configurable.
      # Maybe the following is too much to manage, anyway, let's start

      # 5 default network policies will be created everytime, unless you overwrite this here
      # You can remove this whole block to have the policies created or you can select specific policies
      # which shall be disabled.
      # The 5 policies are:
      #    - Allow Ingress traffic from the OpenShift Router
      #    - Allow OpenShift Monitoring to access and fetch metrics
      #    - Allow inner namespace communication (pod to pod of the same Namespace)
      #    - Allow Kube API Server
      #    - Forbid ANY Egress traffic

      # For example: I would like to disallow Ingress traffic per default.
      default_policies:
        disable_allow_from_ingress: true
        # disable_allow_from_monitoring: false
        # disable_allow_from_same_namespace: false
        # disable_allow_kube_apiserver: false
        # disable_deny_all_egress: false

      networkpolicies:
          # List of NetworkPolicies to create with name and switch if active or not
        - name: netpol1
          active: true

          # The PodSelect based on matchLabels. Could be empty as well
          podSelector:
            matchLabels:
              app: myapplication
              app2: myapplication2

          # Incoming Rules, based on Port and Selectors
          ingressRules:
            - selectors:
                  - podSelector:
                      matchLabels:
                        app: myapplication
                        version: '1.0'
                  - namespaceSelector:
                      matchLabels:
                        testnamespace: "true"
              ports:
                - protocol: TCP
                  port: 443

          # Outgoing Rules, based on Port and Selectors
          egressRules:
            - selectors: []
              ports:
                - port: 2
                  protocol: UDP
            - ports:
                - port: 443
                  protocol: TCP
              selectors:
                - podSelector:
                    matchLabels:
                      app: myapplication
                      version: '1.0'

          # 2nd example
        - name: netpol2
          active: true

          podSelector: {}

          # Incoming Rules, based on ipBlock and Selectors
          ingressRules:
            - selectors:
                  - podSelector: {}
                  - namespaceSelector:
                      matchLabels:
                        testnamespace: "testnamespace"
                  - ipBlock:
                      cidr: 127.0.0.1/24
                      except:
                        - 127.0.0.2/32
              ports:
                - protocol: TCP
                  port: 443
