# Example values files for a customer onboarding
# It is huge, especially the NetworkPolicy part ... however, you do not need to use everything. I tried to make it is configurable as possible.

# Name of the custoemrs. This must be the path.basename.
customer.name: my-main-app

# Normalized name of the customer. This must be LOWER case, otherwise ArgoCD will fail
customer.normalized: my-main-app # name for ArgoCD must be in lower case

# Environment to which these values are valid, this should be the cluster name as visible in ArgoCD
environment: &environment in-cluster

mgmt-cluster: &mgmtcluster https://kubernetes.default.svc
mgmt-cluster-name: &mgmtclustername in-cluster

# Parameters handed over to sub-chart helper-proj-onboarding
helper-proj-onboarding:

  # List of namespaces this customer shall have. Namespace configuration
  namespaces:

    # name of first namespace
    - name: &name customera-project-1

      # shall namespace be created of not
      enabled: true

      # Create a local group with Admin users and the required rolebinding
      # If other systems, like LDAP Group sync is used, you will probaably not need this.
      local_admin_group:
        enabled: true
        users:
          - mona
          - peter

      argocd_rbac_setup:
        argocd_project_1:
          enabled: true
          name: *name
          destinations:
            - name: *mgmtclustername
              server: *mgmtcluster
          sourceRepos:
            - 'https://github.com/tjungbauer/book-import/'
          rbac:
              # Name of the RBAC rule
            - name: write
              # Description of the RBAC rule
              description: "Group to deploy on DEV environment"
              # List of OCP groups that is allowed to manage objects in this project
              oidc_groups:
                - customera-project-1-admins
              # Project policies
              policies:
                - action: get # get, create, update, delete, sync, override
                  permission: allow # allow or deny
                  object: '*' # which kind of objects can be managed, default "*" (all) inside the namespace
                - action: create
                  permission: allow
                - action: update
                  permission: allow
                - action: delete
                  permission: allow
                - action: sync
                  permission: allow
                - action: override
                  permission: allow
          # Sync Windows - when application can be synced or not. Typically used to prevent automatic synchronization during specific time frames
          # but can be used to limit the allowed syncs as well.
          syncWindows:
            - applications:
                - '*'
              clusters:
                - *environment # the cluster we care currently configuring
              namespaces:
                - *name # the namespace of this application
              timezone: 'Europe/Amsterdam' # timezone, default Europe/Amsterdam
              duration: 1h # duration, for example "30m" or "1h" (default 1h)
              kind: allow # allow or deny (default allow)
              manualSync: true # is manual sync allowed ot not (default true)
              schedule: '* * * * *' # cronjob like schedule: Min, Hour, Day, Month, Weekday (default '55 0 1 12 *' )

      # Additional labels for Podsecurity and Monitoring
      additional_settings:
        # Pod Security Standards
        # https://kubernetes.io/docs/concepts/security/pod-security-standards/#restricted
        # Possible values: Privileged, Baseline, Restricted
        # Privileged: Unrestricted policy, providing the widest possible level of permissions. This policy allows for known privilege escalations.
        # Baseline: Minimally restrictive policy which prevents known privilege escalations. Allows the default (minimally specified) Pod configuration.
        # Restricted: Heavily restricted policy, following current Pod hardening best practices.

        # Policy violations will trigger the addition of an audit annotation to the event recorded in the audit log, but are otherwise allowed.
        podsecurity_audit: restricted
        # Policy violations will trigger a user-facing warning, but are otherwise allowed.
        podsecurity_warn: restricted
        # Policy violations will cause the pod to be rejected.
        podsecurity_enforce: restricted
        cluster_monitoring: true

      # list of labels that should be passed
      labels:
        my_additional_label: my_label
        another_label: another_label

      # Configure resourceQuotas
      # Here are a lot of examples, typically, you do not need all of these. cpu/memory is a good start in usually use cases.
      resourceQuotas:
        enabled: true
        # limits of Pods, CPU, Memory, storage, secrets... etc. etc.
        # Byte values will be replace: gi -> Gi, mi -> Mi
        pods: 4
        cpu: 4
        memory: 4Gi
        ephemeral_storage: 4Gi
        replicationcontrollers: 20
        resourcequotas: 20
        services: 100
        secrets: 100
        configmaps: 100
        persistentvolumeclaims: 10
        limits:
          cpu: 4
          memory: 4gi # will be automatically replaced
          ephemeral_storage: 4mi # will be automatically replaced
        requests:
          cpu: 1
          memory: 2Gi
          storage: 50Gi
          ephemeral_storage: 2Gi
        # add here a list of your storage classes you would like to limit as well.
        storageclasses:
          # for example: Storageclass "bronze" has a request limit and a limit ov max. PVCs.
          bronze.storageclass.storage.k8s.io/requests.storage: "10Gi"
          bronze.storageclass.storage.k8s.io/persistentvolumeclaims: "10"

      # Limit Ranges, are optional, if not set here, then default (very small ones) are used
      limitRanges:
        enabled: true
        pod:
          max:
            cpu: 4
            memory: 4Gi
          min:
            cpu: 1
            memory: 2Gi
        container:
          max:
            cpu: 4
            memory: 4Gi
          min:
            cpu: 1
            memory: 2Gi
          default:
            cpu: 1
            memory: 4Gi
          defaultRequest:
            cpu: 1
            memory: 2Gi
        pvc:
          min:
            storage: 1Gi
          max:
            storage: 20Gi

    # name of second namespace
    - name: customera-project-2

      # shall namespace be created of not
      enabled: true

      # Configure resourceQuotas
      # Here are a lot of examples, typically, you do not need all of these. cpu/memory is a good start in usually use cases.
      resourceQuotas:
        enabled: true
        # limits of Pods, CPU, Memory, storage, secrets... etc. etc.
        # Byte values will be replace: gi -> Gi, mi -> Mi
        pods: 4
        cpu: 1
        memory: 2Gi
        ephemeral_storage: 4Gi
        replicationcontrollers: 20
        resourcequotas: 20
        services: 100
        secrets: 100
        configmaps: 100
        persistentvolumeclaims: 10
        limits:
          cpu: 1
          memory: 1gi # will be automatically replaced
          ephemeral_storage: 4mi # will be automatically replaced
        requests:
          cpu: 1
          memory: 2Gi
          storage: 50Gi
          ephemeral_storage: 2Gi
        # add here a list of your storage classes you would like to limit as well.
        storageclasses:
          # for example: Storageclass "bronze" has a request limit and a limit ov max. PVCs.
          bronze.storageclass.storage.k8s.io/requests.storage: "10Gi"
          bronze.storageclass.storage.k8s.io/persistentvolumeclaims: "10"

      # Limit Ranges, are optional, if not set here, then default (very small ones) are used
      limitRanges:
        enabled: true
        pod:
          max:
            cpu: 4
            memory: 100Gi
          min:
            cpu: 1
            memory: 10Gi
        container:
          max:
            cpu: 4
            memory: 100Gi
          min:
            cpu: 1
            memory: 10Gi
          default:
            cpu: 1
            memory: 10Gi
          defaultRequest:
            cpu: 1
            memory: 10Gi
        pvc:
          min:
            storage: 1Gi
          max:
            storage: 20Gi

      # Network Policies ... these are a bit more complex, when you want to keep them fully configurable.
      # Maybe the following is too much to manage, anyway, let's start

      # 5 default network policies will be created everytime, unless you overwrite this here
      # You can remove this whole block to have the policies created or you can select specific policies
      # which shall be disabled.
      # The 5 policies are:
      #    - Allow Ingress traffic from the OpenShift Router
      #    - Allow OpenShift Monitoring to access and fetch metrics
      #    - Allow inner namespace communication (pod to pod of the same Namespace)
      #    - Allow Kube API Server
      #    - Forbid ANY Egress traffic

      # For example: I would like to disallow Ingress traffic per default.
      default_policies:
        disable_allow_from_ingress: true
        # disable_allow_from_monitoring: false
        # disable_allow_from_same_namespace: false
        # disable_allow_kube_apiserver: false
        # disable_deny_all_egress: false

      networkpolicies:
          # List of NetworkPolicies to create with name and switch if active or not
        - name: netpol1
          active: true

          # The PodSelect based on matchLabels. Could be empty as well
          podSelector:
            matchLabels:
              app: myapplication
              app2: myapplication2

          # Incoming Rules, based on Port and Selectors
          ingressRules:
            - selectors:
                  - podSelector:
                      matchLabels:
                        app: myapplication
                        version: '1.0'
                  - namespaceSelector:
                      matchLabels:
                        testnamespace: "true"
              ports:
                - protocol: TCP
                  port: 443

          # Outgoing Rules, based on Port and Selectors
          egressRules:
            - selectors: []
              ports:
                - port: 2
                  protocol: UDP
            - ports:
                - port: 443
                  protocol: TCP
              selectors:
                - podSelector:
                    matchLabels:
                      app: myapplication
                      version: '1.0'

          # 2nd example
        - name: netpol2
          active: true

          podSelector: {}

          # Incoming Rules, based on ipBlock and Selectors
          ingressRules:
            - selectors:
                  - podSelector: {}
                  - namespaceSelector:
                      matchLabels:
                        testnamespace: "testnamespace"
                  - ipBlock:
                      cidr: 127.0.0.1/24
                      except:
                        - 127.0.0.2/32
              ports:
                - protocol: TCP
                  port: 443
